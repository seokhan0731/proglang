//Box의 개념!
fn main() {
    let a = 42;
    let b = Box::new(51);
    //b는 레퍼런스인데, 가리키는 대상은 힙에서 51이라는 i32 자료형을 갖고 있음

    /*  결국 레퍼런스 관련해서 중요한건, 소유권 문제->스택, 힙 구분해줘야한다
        let b=Box::new(a);
        이런 코드가 있을 때, a는 스택에 존재->소유권을 넘기는 것이 아니라 값을 복사해서 들어간다.
        ->코드의 문제 X
     */

    println!("{a}");    //->매크로여서 이렇게 써도 무방
    println!("{}", b);   //->담긴 값이 출력됨->어쩌피 레퍼런스니까

    /*
    *b=*b+1;    ->b가 지금 상황에서는 not mut-> 컴파일 오류 발생
                    b를 mut으로 수정하면 가능 + Box는 애초에 mut이 standard인듯?
                    Box에 있는 값 수정하고 싶으면, mut 레퍼런스 이용해서 바꿔줘야한다!
    println!("{b}");
    */

    /*
    let c: Box<i32>=b;  ->여기서 b의 소유권이 c로 이동하기 때문에 밑의 문장 X
                          만약 b의 소유권을 주기 싫다면 c의 타입을 &Box로 설정하면 된다!
    println!("{b}");
    println!("{c}");
    */

    /*
    **c=63; //c가 b의 레퍼런스일때, let c:&mut Box ... = &mut b일때만 가능
                근데 이렇게 되면 println!("{b}") 이게 안되는데, Y?

                //수정 참조와 읽기 참조의 개념을 알아야된다

                let c: &mut <Box>=&mut b이 상태이면, c만 독점적인 수정권한 존재
                b가 접근하는 순간 접근을 막음(읽기도 안됨), 그냥 b가 먹히는거네(소유권은 근데 갖고있음ㅋㅋ)


    println!("{c}");
    */
}


