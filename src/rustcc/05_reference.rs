/*  05_reference.rs 참조와 빌림

    레퍼런스는 쉽게 말해, 그냥 포인터의 개념에서 살짝 변형된 느낌이라 생각하면 편하다
    c에서의 포인터는 해당 주소가 valid 여부를 따지지 않지만, 러스트의 레퍼런스는 유효한 부분만 가리킬 수 있따

    *소유권(ownership 중요)
    레퍼런스와 관련된 개념으로 소유권이 중요한데, 레퍼런스는 일단 소유권을 원시값에 놔둔 상태로, 값을 빌려온다 생각
    참조할 값의 mut키워드가 없다면 값을 레퍼런스로 빌려왔을 떄, 수정할 수 없다
 */
fn main () {
    let v : i32 = 2025 ;    //v=2025
    let r = &v ;    //r은 v의 레퍼런스 ->r은 v의 값을 빌려온 상태

    println!("v: {}, r: {}", v, r) ;    //v와 r은 같은 값이 출력된다

    /*
    println!("v: {}, r: {:p}", v, r) ;  //주소 형식으로 r을 출력->r은 v의 주소값을 출력한다
    */

    
    let mut v : i32 = 2026 ;    //v는 수정가능한 2026
    let mut w : i32 = 99 ;  //m은 수정 가능한 99

    let mut p = &mut v ;    //p는 v의 레퍼런스이고, p가 가리키는 값은 달라질 수 있다.
    *p = 2024 ; //v=2024
    println!("v: {}", v) ;  //v:2024

    p = &mut w ;    //p의 값 변경 cuz p는 mut이므로
    println!("p: {}", p) ;  //99
    
}



/*  레퍼런스는 불변 참조가 있고, 가변 참조가 있음
결국 레퍼런스의 타입이 &mut이냐, &i32 등의 타입이냐에 따라서, 가리키는 놈을 수정할 수 있는지가 달라진다!

let mut v=2024
let mut p=&mut v
이러면 p의 타입이 &mut이니까 v에 접근해서 값 수정 가능
but 그냥 p=& v 하면 v에 접근해서 값 수정 불가능


 */